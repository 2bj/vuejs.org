title: Пользовательские директивы
type: guide
order: 9
---

## Основы

Vue.js позволяет зарегистрировать пользовательские директивы, позволяя тем самым обучить Vue новому  поведению в обновлении DOM при изменении данных. Можно зарегистрировать глобальную пользовательскую директиву при помощи метода `Vue.directive(id, definition)`, пердав **id директивы**, а после  **объект директивы**. Объект директивы может иметь несколько функций-обработчиков (все необязеталеьные):

- **bind**: вызывается один раз, когда директива подвызывается к элементу впервые.
- **update**: в первый раз вызывается сразу после вызова `bind` с изначальным связанным значением, после вызывается каждый раз при изменении связанного значения. Новое и старое значения передаются в виде аргументов.
- **unbind**: вызывается один раз, когда директива отвязывается от элемента.

**Пример**

``` js
Vue.directive('my-directive', {
  bind: function () {
    // проводим подготовительную работу
    // например, добавляем слушатели событий или "дорогие" вычисления
    // которые необходимо сделать только один раз
  },
  update: function (newValue, oldValue) {
    // делаем что-то на основе обновлённого значения
    // это также будет произведено для изначального значения
  },
  unbind: function () {
    // провести очистку
    // например убрать слушатели событий, установленные в bind()
  }
})
```

Сразу после регистрации, вы можете использовать её в шаблонах Vue.js следующим образом (необходимо добавить префикс Vue.js к имени):

``` html
<div v-my-directive="someValue"></div>
```

Когда вам необходима только функция `update`, можно передать её единственным аргументом вместо объекта директивы:

``` js
Vue.directive('my-directive', function (value) {
  // this function will be used as update()
})
```

Все функции-обработчики будут скопированы в текущий **объект директивы**, который доступен внутри этих функций как контекст `this`. Объект директивы даёт доступ к некоторым полезным свойствам:

- **el**: элемент к которому подвязана директива.
- **vm**: контекстная Модель Представления содержащая эту директиву.
- **expression**: выражение подвязки, исключая аргументы и фильтры.
- **arg**: аргумент, если есть.
- **raw**: ориганльное, не распарсенное выражение.
- **name**: имя директивы, без префикса.

<p class="tip">Рассматривайте все эти опции как достпуные только для чтения и воздерживайтесь от их модификации. Можно также прописать пользовательские свойства к объекту директивы, но будьте внимательны и не затроньте существующие внутренние свойтсва.</p>

Пример пользовательской директивы, использующей некоторые их этих свойств:

``` html
<div id="demo" v-demo="LightSlateGray : msg"></div>
```

``` js
Vue.directive('demo', {
  bind: function () {
    this.el.style.color = '#fff'
    this.el.style.backgroundColor = this.arg
  },
  update: function (value) {
    this.el.innerHTML =
      'name - '       + this.name + '<br>' +
      'raw - '        + this.raw + '<br>' +
      'expression - ' + this.expression + '<br>' +
      'argument - '   + this.arg + '<br>' +
      'value - '      + value
  }
})
var demo = new Vue({
  el: '#demo',
  data: {
    msg: 'hello!'
  }
})
```

**Результат**

<div id="demo" v-demo="LightSlateGray : msg"></div>
<script>
Vue.directive('demo', {
  bind: function () {
    this.el.style.color = '#fff'
    this.el.style.backgroundColor = this.arg
  },
  update: function (value) {
    this.el.innerHTML =
      'name - ' + this.name + '<br>' +
      'raw - ' + this.raw + '<br>' +
      'expression - ' + this.expression + '<br>' +
      'argument - ' + this.arg + '<br>' +
      'value - ' + value
  }
})
var demo = new Vue({
  el: '#demo',
  data: {
    msg: 'hello!'
  }
})
</script>

### Множественное использование

Аргументы, разделённые через запятую, подвязываются как несколько экземпляров директивы. В следующем примере методы директивые вызываются дважды:

``` html
<div v-demo="color: 'white', text: 'hello!'"></div>
```

Достичь единичного привыязвания со всеми аргументами можно передав их в виде объекта:

``` html
<div v-demo="{color: 'white', text: 'hello!'}"></div>
```

``` js
Vue.directive('demo', function (value) {
  console.log(value) // Object {color: 'white', text: 'hello!'}
})
```

## Строковые Директивы

При создании пользователськой директивы можно указать `isLiteral: true`. В этом случае аттрибут будет взят как строковое значение и присовоен как `expression` директивы. Директива не будет пытаться установить отслеживание изменения данных.

Пример:

``` html
<div v-literal-dir="foo"></div>
```

``` js
Vue.directive('literal-dir', {
  isLiteral: true,
  bind: function () {
    console.log(this.expression) // 'foo'
  }
})
```

### Динамическое Строковое Значение

Однако, в случае, когда строковая директива содержит шаблонный тег, поведение меняется:

- Экземпляр директивы будет иметь флаг `this._isDynamicLiteral` установленный в `true`;

- Если нет функции `update`, шаблонный тег будет обработан только один раз и присвоен  `this.expression`. Ослеживания изменения данных не будет.

- Если указана функция `update`, директива **установит** отслеживание изменнеия данных этого выражения и вызовет метод `update` при изменении.

## Директивы с Двусторонней Связью

Если директива будет записывать данные обратно в экземпляр Vue, необходимо указать параметр `twoWay: true`. Этот параметр позволяет использовать `this.set(value)` внтури директивы:

``` js
Vue.directive('example', {
  twoWay: true,
  bind: function () {
    this.handler = function () {
      // устанавливает данные обратно в vm.
      // Если директива свызана как v-example="a.b.c",
      // она попытается установить текущее значение в `vm.a.b.c`
      this.set(this.el.value)
    }.bind(this)
    this.el.addEventListener('input', this.handler)
  },
  unbind: function () {
    this.el.removeEventListener('input', this.handler)
  }
})
```

## Строковые Выражения

Установка `acceptStatement:true` позволяет пользовательской директиве принимать строковые выражения, как это делает `v-on`:

``` html
<div v-my-directive="a++"></div>
```

``` js
Vue.directive('my-directive', {
  acceptStatement: true,
  update: function (fn) {
    // переданное выражение - это функция, которая при вызове
    // обработает выражение "a++" в контексте vm владельца
  }
})
```

Используйте это с осторожностью, т.к. в общем случае  необходимо избегать побочных эффектов в шаблонах.

## Глубокое Отслеживание Изменений

Если директива создана для отслеживания Объекта и нееобходимо, чтобы метод `update` вызывался при изменении свойства внутри объекта, нужно указать `deep: true` в объекте директивы.

``` html
<div v-my-directive="obj"></div>
```

``` js
Vue.directive('my-directive', {
  deep: true,
  update: function (obj) {
    // вызывается при изменении вложенных свойств объекта `obj`
  }
})
```

## Приоритет Директив

Можно указать необязательный порядок приоритета для ваших директив (по-умолчанию 0). Директивы с более высоким приоритетом обрабатываются раньше, чем другие директивы на этом же элементе. Директивы с одинакомым приоритетом обрабатываются согласно порядку вхождения в список аттрибутов элемента, однако этот порядок не гаратнирован для разных браузеров.

Вы можете узнать приоритеты для некоторых встроенных директив в [документации API](/api/directives.html). Дополнительно, логические директивы `v-if` и `v-repeat` считаются "крайними" и всегда имеют наивысший приоритет в процессе обработки.

## Директивы-Элементы

Иногда мы хотим использовать наши директивы в виде пользовательского элемента, а не как аттрибут. Это очень похоже на подход в Angular с "E" режимом директив. Директивы-элементы являются легковесной альтернативой для полнофункциональных Компонент (которые объясняются дальше в руководстве). Можно зарегистрировать пользовательскую директиву элемент следующим образом:

``` js
Vue.elementDirective('my-directive', {
  // такой же API как у обычных директив
  bind: function () {
    // управляем this.el...
  }
})
```

Далее, вместо:

``` html
<div v-my-directive></div>
```

Можно писать так:

``` html
<my-directive></my-directive>
```

Директивы-элементы не могут принимать аргументы или выражения, но могут считывать аттрибуты элемента для определения поведения.

Большая разница с обычными директивами в том, что директивы-элементы являются **крайними**, что означает, как только Vue находит директиву-элемент, то "не трогает" этот элемент и всех его потомков - только директива-элемент сама может манипулировать своим элементом и его потомками. 

Далее, посмотрим как [написать пользовательский фильтр](/guide/custom-filter.html).

*[пользовательские директивы]: custom directives
*[Директивы-Элементы]: Element Directives
*[крайними]: terminal
