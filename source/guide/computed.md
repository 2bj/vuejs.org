title: Вычисляемые свойства
type: guide
order: 8
---

Встроенные выражения в Vue.js очень удобны, но наилучшее применение для них - простые логические операции или объединение строк. Для более сложной логики необходимо использовать **вычисляемые свойства**.

Вычисляемые свойства используются для декларативного описания значений, которые завится от других значений. Когда вы используете вычисляемое свойство в шаблоне, Vue знает, что необходимо обновить DOM, когда любое из значений от которого зависит вычисляемое свойство изменилось. Это очень мощный инструмент, делающий код более декларативным, управляемым данными и потом простым в поддержке.

Использование вычисляемых свойств в большинстве случаев более хорошая идея, чем императивных `$watch`  коллбеков. Например:

``` html
<div id="demo">{{fullName}}</div>
```

``` js
var vm = new Vue({
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  }
})

vm.$watch('firstName', function (val) {
  this.fullName = val + ' ' + this.lastName
})

vm.$watch('lastName', function (val) {
  this.fullName = this.firstName + ' ' + val
})
```

Код выше - императивный и громоздкий. Сравните его с подходом при использовании вычисляемых свойств:

``` js
var vm = new Vue({
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
      fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
```

Это выглядит намного лучше. В дополнение, вы можете создать сеттер для вычисляемого свойства:

``` js
// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
```

### Кеширование Вычисляемых Свойств

До версии 0.12.8, вычисляемые свойства работали лишь как геттеры - функция геттер исполнялась при каждом обращении. В версии 0.12.8 вычисляемые свойства автоматически кешируются и "лениво пересчитываются" только в случае необходимости.

Представим, что у нас есть сложное вычисляемое свойство A, которое требует пройтись по громадному Массиву и произвести множество вычислений. Далее, у нас может быть другое вычисляемое свойство, зависящее от А. Без кеширования мы вызывали бы геттер для A намного чаще, чем требуется, что приведёт к проблемам с производительностью. С кешированием, значнание A закешировано до того момента, пока не поменяются его зависимости, и доступ к нему не будет вызывать ненужные вычисления.

Однако, очень важно понимать что считается "реактивной зависимостью":

``` js
var vm = new Vue({
  data: {
    msg: 'hi'
  },
  computed: {
    example: {
      return Date.now() + this.msg
    }
  }
})
```

В примере выше, вычисляемое свойство ссылается на `vm.msg`. Т.к. это свойство отслеживается экземпляром Vue, то оно считается реактивной зависимостью. Как только `vm.msg` изменится, значение `vm.example` будет пересчитано.

Однако, `Date.now()` это **не** реактивная зависимость, т.к. она никак не связана с отслеживанием зависимостей экземпляра Vue. Поэтому при программном обращении к `vm.example` вы увидите, что временной штамп остаётся одни и тем же пока `vm.msg` не вызовет пересчёт свойства.

Иногда вы можете захотеть оставить поведение простого геттера и вызывать пересчет при каждом обращении к `vm.example`. Начиная с 0.12.11 возможно отключить кеширование для определённых вчисляемых свойств:

``` js
computed: {
  example: {
    cache: false,
    get: function () {
      return Date.now() + this.msg
    }
  }
}
```

Теперь, при каждом доступе к `vm.example`, временной штамп будет актуален. Но это поведение будет работать только для программного обращения к этой функции в JavaScript коде; привязка данных в любом случае управляется зависимостями. Если вы привязываетесь к вычисляемому свойству в шаблоне `{% raw %}{{example}}{% endraw %}`, то DOM будет обновлён только в случае изменения реактивной зависимости.

Далее, давайте разберёмся как [написать пользовательскую директиву](/guide/custom-directive.html).
